<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Letter Race 3D</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui {
      position: fixed; left: 12px; right: 12px; top: 10px;
      display: flex; gap: 10px; align-items: center; justify-content: space-between;
      pointer-events: none;
    }
    .pill {
      pointer-events: auto;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color: #fff;
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display:flex; align-items:center; gap:10px;
      user-select: none;
    }
    #targetLetter { font-size: 18px; font-weight: 800; display:flex; align-items:center; gap:10px; }
    #bigLetter {
      width: 46px; height: 46px; border-radius: 12px;
      background: rgba(255,255,255,0.16);
      display:flex; align-items:center; justify-content:center;
      font-size: 24px; font-weight: 900;
      text-transform: lowercase;
    }
    #status { font-size: 18px; font-weight: 800; }
    #help {
      position: fixed; left: 12px; right: 12px; bottom: 12px;
      display:flex; justify-content: space-between; gap: 10px;
      pointer-events: none;
    }
    .btn {
      pointer-events: auto;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color:#fff;
      padding: 14px 16px;
      border-radius: 16px;
      font-weight: 800;
      min-width: 120px;
      text-align:center;
      user-select:none;
      touch-action: manipulation;
    }
    #overlay {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(ellipse at center, rgba(20,30,45,0.92), rgba(5,7,10,0.96));
      color:#fff;
      z-index: 10;
    }
    #card {
      width: min(760px, calc(100% - 24px));
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 18px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #card h1 { margin: 0 0 8px 0; font-size: 22px; }
    #card p { margin: 6px 0; opacity: 0.92; line-height: 1.35; }
    #card .row { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    #card .row button {
      background: rgba(255,255,255,0.16);
      border: 1px solid rgba(255,255,255,0.16);
      color:#fff;
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 900;
      cursor: pointer;
    }
    canvas { display:block; }
  </style>
</head>
<body>

<div id="overlay">
  <div id="card">
    <h1>Letter Race 3D</h1>
    <p>Rustige race, pak de juiste kleine letter, de klank wordt fonemisch uitgesproken.</p>
    <p>Bediening, tik links of rechts om van baan te wisselen.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="tempoBtn">Tempo: extra rustig</button>
      <button id="curveBtn">Bochten: aan</button>
      <button id="soundBtn">Geluid: aan</button>
    </div>
  </div>
</div>

<div id="ui">
  <div class="pill" id="targetLetter">
    <div id="bigLetter">b</div>
    <div>Doelletter</div>
  </div>
  <div class="pill">
    <div id="status">ðŸ™‚</div>
    <div id="score">Score: 0</div>
  </div>
</div>

<div id="help">
  <div class="btn" id="leftBtn">Links</div>
  <div class="btn" id="rightBtn">Rechts</div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  let scene, camera, renderer;
  let car, road, laneMarks = [];
  let lane = 1;

  // Rijstroken zonder bocht, bocht komt als offset erbij
  const laneOffsets = [-2.2, 0, 2.2];
  const carZ = 2.2;

  // Tempo
  let baseSpeed = 0.030;
  let speed = baseSpeed;
  let turboTime = 0;
  let slowTime = 0;

  // Letters
  let pickups = [];
  const activeLetters = ["b","g","v","m","z","h","k","l","s","w"];
  let target = "b";
  let score = 0;

  // Spel
  let running = false;
  let lastSpawnZ = -12;
  const rng = () => Math.random();

  // Bochten
  let curvesOn = true;
  let curvePhase = 0;
  const curvePeriod = 120;     // groter is rustiger slingeren
  const curveAmp = 1.15;       // hoe ver de baan uitschuift

  // UI
  const uiBig = document.getElementById("bigLetter");
  const uiStatus = document.getElementById("status");
  const uiScore = document.getElementById("score");
  const overlay = document.getElementById("overlay");
  let soundOn = true;

  // Fonemische klanken
  // Geen losse letters, geen letternamen
  const phoneme = {
    b: "buh",
    g: "guh",
    v: "vuh",
    m: "mmm",
    z: "zzzz",
    h: "hhh",
    k: "kuh",
    l: "luh",
    s: "sss",
    w: "wuh"
  };

  function speakPhoneme(letter) {
    if (!soundOn) return;
    try {
      if (!("speechSynthesis" in window)) return;
      window.speechSynthesis.cancel();

      const say = phoneme[letter] || "";
      if (!say) return;

      const u = new SpeechSynthesisUtterance(say);
      u.lang = "nl-NL";
      u.rate = 0.78;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    } catch {}
  }

  function beep(ok = true) {
    if (!soundOn) return;
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine";
      o.frequency.value = ok ? 480 : 210;
      g.gain.value = 0.055;
      o.connect(g);
      g.connect(ctx.destination);
      o.start();
      setTimeout(() => { o.stop(); ctx.close(); }, ok ? 90 : 130);
    } catch {}
  }

  function setTarget(newTarget) {
    target = String(newTarget).toLowerCase();
    uiBig.textContent = target;
    speakPhoneme(target);
  }

  function pickNewTarget() {
    const next = activeLetters[Math.floor(rng() * activeLetters.length)];
    setTarget(next);
  }

  function setStatus(emoji) { uiStatus.textContent = emoji; }
  function updateScore() { uiScore.textContent = `Score: ${score}`; }

  function makeTextSprite(letter) {
    const canvas = document.createElement("canvas");
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0,0,256,256);

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fillRect(20,20,216,216);

    ctx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.fillText(String(letter).toLowerCase(), 128, 138);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 8;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(1.25, 1.25, 1);
    return sprite;
  }

  function trackOffsetX(z) {
    if (!curvesOn) return 0;
    // z is negatief voor de horizon, curvePhase schuift langzaam mee
    return curveAmp * Math.sin((z + curvePhase) / curvePeriod * Math.PI * 2);
  }

  function laneXAtZ(laneIndex, z) {
    return trackOffsetX(z) + laneOffsets[laneIndex];
  }

  function createPickup(letter, laneIndex, z) {
    const group = new THREE.Group();

    const baseGeom = new THREE.BoxGeometry(1.05, 0.7, 1.05);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x9aa6b2, roughness: 0.45, metalness: 0.18 });
    const base = new THREE.Mesh(baseGeom, baseMat);
    base.position.y = 0.38;
    group.add(base);

    const sprite = makeTextSprite(letter);
    sprite.position.set(0, 1.05, 0.55);
    group.add(sprite);

    group.position.set(laneXAtZ(laneIndex, z), 0, z);
    group.userData = {
      letter: String(letter).toLowerCase(),
      laneIndex,
      hit: false
    };

    scene.add(group);
    pickups.push(group);
  }

  function spawnSet() {
    // Veel ruimte tussen sets, leestijd
    const z = lastSpawnZ - 36 - rng() * 18;
    lastSpawnZ = z;

    // Kies 1 baan voor de goede letter
    const correctLane = Math.floor(rng() * 3);

    // Altijd 1 correcte letter
    createPickup(target, correctLane, z);

    // Twee foute letters, nooit target
    const others = activeLetters.filter(l => l !== target);
    for (let i = 0; i < 3; i++) {
      if (i === correctLane) continue;
      const l = others[Math.floor(rng() * others.length)];
      createPickup(l, i, z);
    }
  }

  // Auto textures
  function setCarTexture(key) {
    if (!car || !car.userData || !car.userData.plane) return;
    const t = car.userData.tex[key];
    if (!t) return;
    car.userData.plane.material.map = t;
    car.userData.plane.material.needsUpdate = true;
  }

  function setupThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 12, 160);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    // Orthographic camera
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 10.8;
    camera = new THREE.OrthographicCamera(
      -viewSize * aspect, viewSize * aspect,
      viewSize, -viewSize,
      0.1, 500
    );
    camera.position.set(0, 16, 12);
    camera.lookAt(0, 0.8, -18);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x1b2430, 1.0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.05);
    dir.position.set(6, 12, 6);
    scene.add(dir);

    // Weg
    const roadGeom = new THREE.PlaneGeometry(12.5, 760);
    const roadMat = new THREE.MeshStandardMaterial({ color: 0x111a24, roughness: 0.95, metalness: 0.0 });
    road = new THREE.Mesh(roadGeom, roadMat);
    road.rotation.x = -Math.PI / 2;
    road.position.z = -260;
    scene.add(road);

    // Rijstrookmarkeringen als segmenten die met de bocht mee schuiven
    const lineGeom = new THREE.BoxGeometry(0.12, 0.02, 5.4);
    const lineMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.85, metalness: 0.0 });

    for (let i = 0; i < 44; i++) {
      const z = -i * 16;

      const a = new THREE.Mesh(lineGeom, lineMat);
      a.position.set(laneXAtZ(1, z) - 1.1, 0.02, z);
      a.userData = { baseX: -1.1 };
      scene.add(a);
      laneMarks.push(a);

      const b = new THREE.Mesh(lineGeom, lineMat);
      b.position.set(laneXAtZ(1, z) + 1.1, 0.02, z);
      b.userData = { baseX: 1.1 };
      scene.add(b);
      laneMarks.push(b);
    }

    // Auto als plaatje
    const texLoader = new THREE.TextureLoader();
    const carTex = {
      straight: texLoader.load("./car_straight.png"),
      left: texLoader.load("./car_left.png"),
      right: texLoader.load("./car_right.png"),
    };

    for (const k of Object.keys(carTex)) {
      carTex[k].colorSpace = THREE.SRGBColorSpace;
      carTex[k].anisotropy = 8;
    }

    const carGroup = new THREE.Group();

    const carPlaneGeom = new THREE.PlaneGeometry(2.8, 2.8);
    const carPlaneMat = new THREE.MeshBasicMaterial({ map: carTex.straight, transparent: true });
    const carPlane = new THREE.Mesh(carPlaneGeom, carPlaneMat);
    carPlane.position.set(0, 1.15, 0);
    carPlane.rotation.x = -0.22;
    carGroup.add(carPlane);

    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(1.05, 26),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25 })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.02;
    carGroup.add(shadow);

    car = carGroup;
    car.position.set(laneXAtZ(lane, carZ), 0, carZ);
    scene.add(car);

    car.userData = {
      plane: carPlane,
      tex: carTex,
      blinkFrames: 0,
      wobbleFrames: 0,
      wobbleDir: 0,
      holdKey: "straight"
    };

    setTarget(activeLetters[0]);

    // Eerste setjes
    for (let i = 0; i < 3; i++) spawnSet();

    window.addEventListener("resize", onResize);
  }

  function onResize() {
    if (!renderer || !camera) return;
    renderer.setSize(window.innerWidth, window.innerHeight);

    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 10.8;
    camera.left = -viewSize * aspect;
    camera.right = viewSize * aspect;
    camera.top = viewSize;
    camera.bottom = -viewSize;
    camera.updateProjectionMatrix();
  }

  function moveLane(dir) {
    const prev = lane;
    lane = Math.max(0, Math.min(2, lane + dir));
    if (lane === prev) return;

    // Langer draaien zichtbaar
    const blinkKey = dir < 0 ? "left" : "right";
    car.userData.holdKey = blinkKey;
    car.userData.blinkFrames = 18;    // langer dan eerst
    setCarTexture(blinkKey);

    // Langer wiebelen, maar nog steeds rustig
    car.userData.wobbleFrames = 22;
    car.userData.wobbleDir = dir < 0 ? -1 : 1;
  }

  function checkCollisions() {
    for (const p of pickups) {
      if (p.userData.hit) continue;

      const dz = Math.abs(p.position.z - carZ);
      const dx = Math.abs(p.position.x - car.position.x);

      if (dz < 1.1 && dx < 1.0) {
        p.userData.hit = true;

        const ok = p.userData.letter === target;
        if (ok) {
          score += 1;
          turboTime = 75;
          slowTime = 0;
          setStatus("ðŸ˜„");
          beep(true);
          pickNewTarget();
        } else {
          slowTime = 95;
          turboTime = 0;
          setStatus("ðŸ˜¬");
          beep(false);
          speakPhoneme(target);
        }
        updateScore();
        scene.remove(p);
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);
  }

  function tick() {
    if (!running) return;

    // Bocht fase, heel langzaam opschuiven
    curvePhase += speed * 10;

    // Auto richting rijstrook, inclusief bocht offset
    const desiredX = laneXAtZ(lane, carZ);
    car.position.x += (desiredX - car.position.x) * 0.11;

    // Gedraaide auto langer vasthouden
    if (car?.userData?.blinkFrames > 0) {
      car.userData.blinkFrames -= 1;
      if (car.userData.blinkFrames === 0) {
        setCarTexture("straight");
        car.userData.holdKey = "straight";
      }
    }

    // Wiebelen langer
    if (car?.userData?.wobbleFrames > 0) {
      car.userData.wobbleFrames -= 1;
      const t = car.userData.wobbleFrames / 22;
      const wobble = Math.sin((1 - t) * Math.PI) * 0.16 * car.userData.wobbleDir;
      car.rotation.z = wobble;
      car.rotation.y = wobble * 0.25;
    } else {
      car.rotation.z += (0 - car.rotation.z) * 0.18;
      car.rotation.y += (0 - car.rotation.y) * 0.18;
    }

    // Snelheid
    let targetSpeed = baseSpeed;
    if (turboTime > 0) {
      turboTime -= 1;
      targetSpeed = baseSpeed * 1.12;
    } else if (slowTime > 0) {
      slowTime -= 1;
      targetSpeed = baseSpeed * 0.58;
    } else {
      setStatus("ðŸ™‚");
    }
    speed += (targetSpeed - speed) * 0.06;

    // Weg schuift met bocht mee
    road.position.x = trackOffsetX(road.position.z);

    // Markeringen bewegen en krijgen bocht offset
    for (const m of laneMarks) {
      m.position.z += speed * 10;
      if (m.position.z > 10) m.position.z = -760;

      const off = trackOffsetX(m.position.z);
      m.position.x = off + m.userData.baseX;
    }

    // Pickups bewegen, en blijven op de bochtige rijstrook
    for (const p of pickups) {
      p.position.z += speed * 10;

      // bocht volgen
      const lx = laneXAtZ(p.userData.laneIndex, p.position.z);
      p.position.x = lx;

      if (p.position.z > 10) {
        scene.remove(p);
        p.userData.hit = true;
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);

    // Altijd genoeg lettersets
    while (pickups.length < 9) spawnSet();

    checkCollisions();

    // Camera volgt rustig
    camera.position.x += (car.position.x - camera.position.x) * 0.06;
    camera.lookAt(camera.position.x, 0.8, -18);

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  function bindControls() {
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");

    const left = () => moveLane(-1);
    const right = () => moveLane(1);

    leftBtn.addEventListener("pointerdown", left);
    rightBtn.addEventListener("pointerdown", right);

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") left();
      if (e.key === "ArrowRight") right();
    });

    window.addEventListener("pointerdown", (e) => {
      const x = e.clientX / window.innerWidth;
      if (x < 0.40) left();
      else if (x > 0.60) right();
    });
  }

  function startGame() {
    if (!scene) setupThree();
    running = true;
    overlay.style.display = "none";
    tick();
  }

  document.getElementById("startBtn").addEventListener("click", startGame);

  document.getElementById("tempoBtn").addEventListener("click", (e) => {
    if (baseSpeed > 0.024) {
      baseSpeed = 0.020;
      e.target.textContent = "Tempo: super rustig";
    } else {
      baseSpeed = 0.030;
      e.target.textContent = "Tempo: extra rustig";
    }
  });

  document.getElementById("curveBtn").addEventListener("click", (e) => {
    curvesOn = !curvesOn;
    e.target.textContent = curvesOn ? "Bochten: aan" : "Bochten: uit";
  });

  document.getElementById("soundBtn").addEventListener("click", (e) => {
    soundOn = !soundOn;
    e.target.textContent = soundOn ? "Geluid: aan" : "Geluid: uit";
    if (!soundOn) {
      try { window.speechSynthesis.cancel(); } catch {}
    } else {
      speakPhoneme(target);
    }
  });

  bindControls();
</script>
</body>
</html>