<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Letter Race 3D</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui { position: fixed; left: 12px; right: 12px; top: 10px; display:flex; justify-content: space-between; pointer-events:none; gap: 10px; }
    .pill { pointer-events:auto; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.14); color:#fff; padding: 10px 12px; border-radius: 14px; display:flex; gap: 10px; align-items:center; user-select:none; }
    #bigLetter { width:46px; height:46px; border-radius: 12px; background: rgba(255,255,255,0.16); display:flex; align-items:center; justify-content:center; font-size:24px; font-weight:900; text-transform: lowercase; }
    #help { position: fixed; left: 12px; right: 12px; bottom: 12px; display:flex; justify-content: space-between; pointer-events:none; gap: 10px; }
    .btn { pointer-events:auto; background: rgba(255,255,255,0.10); border: 1px solid rgba(255,255,255,0.14); color:#fff; padding: 14px 16px; border-radius: 16px; font-weight:800; min-width: 120px; text-align:center; user-select:none; touch-action: manipulation; }
    #overlay { position: fixed; inset:0; display:flex; align-items:center; justify-content:center; background: radial-gradient(ellipse at center, rgba(20,30,45,0.92), rgba(5,7,10,0.96)); color:#fff; z-index: 10; }
    #card { width: min(760px, calc(100% - 24px)); background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.14); border-radius: 18px; padding: 18px; }
    #card h1 { margin: 0 0 8px 0; font-size: 22px; }
    #card p { margin: 6px 0; opacity: 0.92; line-height: 1.35; }
    #card .row { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    #card .row button { background: rgba(255,255,255,0.16); border: 1px solid rgba(255,255,255,0.16); color:#fff; padding: 12px 14px; border-radius: 14px; font-weight: 900; cursor: pointer; }
    #err { margin-top: 10px; padding: 10px 12px; border-radius: 12px; background: rgba(255,80,80,0.12); border: 1px solid rgba(255,80,80,0.18); display:none; white-space: pre-wrap; font-size: 13px; line-height: 1.25; }
    canvas { display:block; }
  </style>
</head>
<body>

<div id="overlay">
  <div id="card">
    <h1>Letter Race 3D</h1>
    <p>Rustig rijden, pak de juiste kleine letter.</p>
    <p>Tik links of rechts om van rijstrook te wisselen.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="tempoBtn">Tempo: extra rustig</button>
    </div>
    <div id="err"></div>
  </div>
</div>

<div id="ui">
  <div class="pill">
    <div id="bigLetter">b</div>
    <div>Doelletter</div>
  </div>
  <div class="pill">
    <div id="score">Score: 0</div>
  </div>
</div>

<div id="help">
  <div class="btn" id="leftBtn">Links</div>
  <div class="btn" id="rightBtn">Rechts</div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  const errBox = document.getElementById("err");
  function showErr(msg) { errBox.style.display = "block"; errBox.textContent = msg; }
  window.addEventListener("error", (e) => showErr("Er ging iets mis:\n" + (e?.message || e)));

  let scene, camera, renderer;

  let car, lane = 1;
  const laneOffsets = [-2.2, 0, 2.2];
  const carZ = 2.4;

  let baseSpeed = 0.026;
  let speed = baseSpeed;

  const activeLetters = ["b","g","v","m","z","h","k","l","s","w"];
  let target = "b";
  let score = 0;

  let pickups = [];
  let lastSpawnZ = -26;

  const uiBig = document.getElementById("bigLetter");
  const uiScore = document.getElementById("score");
  const overlay = document.getElementById("overlay");

  const rng = () => Math.random();

  function setTarget(l) {
    target = String(l).toLowerCase();
    uiBig.textContent = target;
  }
  function pickNewTarget() {
    setTarget(activeLetters[Math.floor(rng() * activeLetters.length)]);
  }
  function updateScore() {
    uiScore.textContent = "Score: " + score;
  }

  // Weg als echt lint met constante breedte
  const ROAD = {
    width: 12.0,
    halfW: 6.0,
    zNear: 10,     // dicht bij camera
    zFar: -170,    // ver weg
    segments: 140, // hoe hoger, hoe gladder
    phase: 0,

    // bocht gedrag: meestal recht, soms een bocht die even aanhoudt
    gatePeriod: 520,
    gateThreshold: 0.70,
    gateSharpness: 12,

    // bocht vorm tijdens gate
    turnAmp: 3.6,
    turnPeriod: 260,

    // klein beetje leven, heel subtiel
    microAmp: 0.6,
    microPeriod: 120
  };

  function smoothStep(t) { return t * t * (3 - 2 * t); }

  function gateValue(z) {
    const x = ((z + ROAD.phase) / ROAD.gatePeriod) * Math.PI * 2;
    const s = (Math.sin(x) + 1) * 0.5;
    const t = THREE.MathUtils.clamp((s - ROAD.gateThreshold) * ROAD.gateSharpness, 0, 1);
    return smoothStep(t);
  }

  function centerX(z) {
    const g = gateValue(z);
    const main = ROAD.turnAmp * Math.sin(((z + ROAD.phase) / ROAD.turnPeriod) * Math.PI * 2) * g;
    const micro = ROAD.microAmp * Math.sin(((z + ROAD.phase) / ROAD.microPeriod) * Math.PI * 2) * (g * 0.35);
    return main + micro;
  }

  function centerDeriv(z) {
    const dz = 0.35;
    return (centerX(z + dz) - centerX(z - dz)) / (2 * dz);
  }

  function laneXAtZ(laneIndex, z) {
    return centerX(z) + laneOffsets[laneIndex];
  }

  // Road geometry (buffer) met constante breedte
  let roadMesh, roadGeom, roadPos;
  let edgeMesh, edgeGeom, edgePos;
  let dashMesh, dashGeom, dashPos;

  function buildRoad() {
    const seg = ROAD.segments;
    const vCount = (seg + 1) * 2;

    // Road surface
    roadGeom = new THREE.BufferGeometry();
    roadPos = new Float32Array(vCount * 3);
    const roadUv = new Float32Array(vCount * 2);
    const roadIdx = [];

    for (let i = 0; i <= seg; i++) {
      const t = i / seg;
      // z van dichtbij naar ver weg
      const z = THREE.MathUtils.lerp(ROAD.zNear, ROAD.zFar, t);

      // placeholder, vullen we in updateRoad()
      const li = i * 2;
      roadUv[(li + 0) * 2 + 0] = 0; roadUv[(li + 0) * 2 + 1] = t * 6;
      roadUv[(li + 1) * 2 + 0] = 1; roadUv[(li + 1) * 2 + 1] = t * 6;

      if (i < seg) {
        const a = li;
        const b = li + 1;
        const c = li + 2;
        const d = li + 3;
        roadIdx.push(a, c, b, b, c, d);
      }
    }

    roadGeom.setAttribute("position", new THREE.BufferAttribute(roadPos, 3));
    roadGeom.setAttribute("uv", new THREE.BufferAttribute(roadUv, 2));
    roadGeom.setIndex(roadIdx);
    roadGeom.computeVertexNormals();

    const roadMat = new THREE.MeshStandardMaterial({
      color: 0x111a24,
      roughness: 0.95,
      metalness: 0.0
    });
    roadMesh = new THREE.Mesh(roadGeom, roadMat);
    scene.add(roadMesh);

    // Edge lines, links en rechts
    edgeGeom = new THREE.BufferGeometry();
    edgePos = new Float32Array((seg + 1) * 2 * 3); // 2 lijnen, elk seg+1 punten
    edgeGeom.setAttribute("position", new THREE.BufferAttribute(edgePos, 3));
    const edgeMat = new THREE.LineBasicMaterial({ color: 0x6f7a86, transparent: true, opacity: 0.55 });
    edgeMesh = new THREE.LineSegments(edgeGeom, edgeMat);
    scene.add(edgeMesh);

    // Center dash
    dashGeom = new THREE.BufferGeometry();
    // aantal dash segmenten, we tekenen korte lijnstukjes
    const dashCount = 34;
    dashPos = new Float32Array(dashCount * 2 * 3);
    dashGeom.setAttribute("position", new THREE.BufferAttribute(dashPos, 3));
    const dashMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.65 });
    dashMesh = new THREE.LineSegments(dashGeom, dashMat);
    scene.add(dashMesh);

    updateRoad();
  }

  function updateRoad() {
    const seg = ROAD.segments;
    const halfW = ROAD.halfW;

    // Road surface vertices
    for (let i = 0; i <= seg; i++) {
      const t = i / seg;
      const z = THREE.MathUtils.lerp(ROAD.zNear, ROAD.zFar, t);

      const cx = centerX(z);
      const d = centerDeriv(z);
      // normal in xz vlak (perpendiculair aan richting)
      const invLen = 1 / Math.sqrt(1 + d * d);
      const nx = invLen;
      const nz = -d * invLen;

      const lx = cx - nx * halfW;
      const lz = z - nz * halfW;
      const rx = cx + nx * halfW;
      const rz = z + nz * halfW;

      const li = i * 2;
      roadPos[(li + 0) * 3 + 0] = lx;
      roadPos[(li + 0) * 3 + 1] = 0;
      roadPos[(li + 0) * 3 + 2] = lz;

      roadPos[(li + 1) * 3 + 0] = rx;
      roadPos[(li + 1) * 3 + 1] = 0;
      roadPos[(li + 1) * 3 + 2] = rz;

      // Edge lines positions (LineSegments needs pairs)
      // We build two polylines as segments: (i) to (i+1)
      if (i < seg) {
        const nextT = (i + 1) / seg;
        const z2 = THREE.MathUtils.lerp(ROAD.zNear, ROAD.zFar, nextT);
        const cx2 = centerX(z2);
        const d2 = centerDeriv(z2);
        const invLen2 = 1 / Math.sqrt(1 + d2 * d2);
        const nx2 = invLen2;
        const nz2 = -d2 * invLen2;

        const lx2 = cx2 - nx2 * halfW;
        const lz2 = z2 - nz2 * halfW;
        const rx2 = cx2 + nx2 * halfW;
        const rz2 = z2 + nz2 * halfW;

        // left edge segment
        const eBase = i * 2 * 3;
        edgePos[eBase + 0] = lx;  edgePos[eBase + 1] = 0.03; edgePos[eBase + 2] = lz;
        edgePos[eBase + 3] = lx2; edgePos[eBase + 4] = 0.03; edgePos[eBase + 5] = lz2;

        // right edge segment
        const eBaseR = (seg * 2 * 3) + (i * 2 * 3);
        edgePos[eBaseR + 0] = rx;  edgePos[eBaseR + 1] = 0.03; edgePos[eBaseR + 2] = rz;
        edgePos[eBaseR + 3] = rx2; edgePos[eBaseR + 4] = 0.03; edgePos[eBaseR + 5] = rz2;
      }
    }

    roadGeom.attributes.position.needsUpdate = true;
    roadGeom.computeVertexNormals();

    edgeGeom.attributes.position.needsUpdate = true;

    // Center dash, korte segmenten met vaste spacing
    const dashCount = 34;
    const dashLen = 3.0;
    const gap = 4.0;
    let zStart = ROAD.zNear - 2;

    for (let i = 0; i < dashCount; i++) {
      const zA = zStart - i * (dashLen + gap);
      const zB = zA - dashLen;

      const xA = centerX(zA);
      const xB = centerX(zB);

      const di = i * 2 * 3;
      dashPos[di + 0] = xA; dashPos[di + 1] = 0.05; dashPos[di + 2] = zA;
      dashPos[di + 3] = xB; dashPos[di + 4] = 0.05; dashPos[di + 5] = zB;
    }
    dashGeom.attributes.position.needsUpdate = true;
  }

  // Letters
  function makeTextSprite(letter) {
    const canvas = document.createElement("canvas");
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "rgba(255,255,255,0.10)";
    ctx.fillRect(0, 0, 256, 256);

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fillRect(20, 20, 216, 216);

    ctx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.fillText(String(letter).toLowerCase(), 128, 138);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 8;

    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(1.25, 1.25, 1);
    return sprite;
  }

  function createPickup(letter, laneIndex, z) {
    const group = new THREE.Group();

    const base = new THREE.Mesh(
      new THREE.BoxGeometry(1.05, 0.7, 1.05),
      new THREE.MeshStandardMaterial({ color: 0x9aa6b2, roughness: 0.45, metalness: 0.18 })
    );
    base.position.y = 0.38;
    group.add(base);

    const sprite = makeTextSprite(letter);
    sprite.position.set(0, 1.05, 0.55);
    group.add(sprite);

    group.position.set(laneXAtZ(laneIndex, z), 0, z);
    group.userData = { letter: String(letter).toLowerCase(), laneIndex, hit: false };

    scene.add(group);
    pickups.push(group);
  }

  function spawnSet() {
    const z = lastSpawnZ - 48 - rng() * 22;
    lastSpawnZ = z;

    const correctLane = Math.floor(rng() * 3);
    createPickup(target, correctLane, z);

    const others = activeLetters.filter(l => l !== target);
    for (let i = 0; i < 3; i++) {
      if (i === correctLane) continue;
      const l = others[Math.floor(rng() * others.length)];
      createPickup(l, i, z);
    }
  }

  function setCarTexture(key) {
    if (!car || !car.userData || !car.userData.plane) return;
    const t = car.userData.tex[key];
    if (!t) return;
    car.userData.plane.material.map = t;
    car.userData.plane.material.needsUpdate = true;
  }

  function setupThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 18, 230);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setClearColor(0x0b0f14, 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    // Orthographic camera, rustig en duidelijk
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 12.0;
    camera = new THREE.OrthographicCamera(
      -viewSize * aspect, viewSize * aspect,
      viewSize, -viewSize,
      0.1, 900
    );

    camera.position.set(0, 18, 18);
    camera.lookAt(0, 0.6, -60);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x1b2430, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.05);
    dir.position.set(6, 14, 6);
    scene.add(dir);

    buildRoad();

    // Auto textures
    const texLoader = new THREE.TextureLoader();
    texLoader.setCrossOrigin("anonymous");

    const carTex = {
      straight: texLoader.load("./car_straight.png", undefined, undefined, () => showErr("Kan car_straight.png niet laden. Staat het bestand naast index.html, exact zo gespeld?")),
      left: texLoader.load("./car_left.png", undefined, undefined, () => showErr("Kan car_left.png niet laden. Controleer bestandsnaam en map.")),
      right: texLoader.load("./car_right.png", undefined, undefined, () => showErr("Kan car_right.png niet laden. Controleer bestandsnaam en map."))
    };

    for (const k of Object.keys(carTex)) {
      carTex[k].colorSpace = THREE.SRGBColorSpace;
      carTex[k].anisotropy = 8;
    }

    const carGroup = new THREE.Group();

    const carPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(3.0, 3.0),
      new THREE.MeshBasicMaterial({ map: carTex.straight, transparent: true, color: 0xffffff })
    );
    carPlane.position.set(0, 1.15, 0);
    carPlane.rotation.x = -0.22;
    carGroup.add(carPlane);

    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(1.05, 26),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.22 })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.02;
    carGroup.add(shadow);

    car = carGroup;
    car.position.set(laneXAtZ(lane, carZ), 0, carZ);
    car.rotation.set(0, 0, 0);
    scene.add(car);

    car.userData = { plane: carPlane, tex: carTex, blinkFrames: 0 };

    setTarget(activeLetters[0]);
    for (let i = 0; i < 3; i++) spawnSet();

    window.addEventListener("resize", onResize);
  }

  function onResize() {
    if (!renderer || !camera) return;
    renderer.setSize(window.innerWidth, window.innerHeight);

    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 12.0;
    camera.left = -viewSize * aspect;
    camera.right = viewSize * aspect;
    camera.top = viewSize;
    camera.bottom = -viewSize;
    camera.updateProjectionMatrix();
  }

  function moveLane(dir) {
    const prev = lane;
    lane = Math.max(0, Math.min(2, lane + dir));
    if (lane === prev) return;

    const key = dir < 0 ? "left" : "right";
    setCarTexture(key);
    car.userData.blinkFrames = 26;
  }

  function checkCollisions() {
    for (const p of pickups) {
      if (p.userData.hit) continue;

      const dz = Math.abs(p.position.z - carZ);
      const dx = Math.abs(p.position.x - car.position.x);

      if (dz < 1.15 && dx < 1.05) {
        p.userData.hit = true;

        if (p.userData.letter === target) {
          score += 1;
          pickNewTarget();
        }
        updateScore();
        scene.remove(p);
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);
  }

  function tick() {
    speed += (baseSpeed - speed) * 0.06;
    const forward = speed * 10;

    ROAD.phase += forward;

    updateRoad();

    // Auto alleen naar rijstrook, geen meedraaien
    const desiredX = laneXAtZ(lane, carZ);
    car.position.x += (desiredX - car.position.x) * 0.11;
    car.rotation.set(0, 0, 0);

    if (car.userData.blinkFrames > 0) {
      car.userData.blinkFrames -= 1;
      if (car.userData.blinkFrames === 0) setCarTexture("straight");
    }

    for (const p of pickups) {
      p.position.z += forward;
      p.position.x = laneXAtZ(p.userData.laneIndex, p.position.z);

      if (p.position.z > 12) {
        scene.remove(p);
        p.userData.hit = true;
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);

    while (pickups.length < 9) spawnSet();

    checkCollisions();

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  function startGame() {
    setupThree();
    overlay.style.display = "none";
    tick();
  }

  document.getElementById("startBtn").addEventListener("click", startGame);

  document.getElementById("tempoBtn").addEventListener("click", (e) => {
    if (baseSpeed > 0.022) {
      baseSpeed = 0.018;
      e.target.textContent = "Tempo: super rustig";
    } else {
      baseSpeed = 0.026;
      e.target.textContent = "Tempo: extra rustig";
    }
  });

  document.getElementById("leftBtn").addEventListener("pointerdown", () => moveLane(-1));
  document.getElementById("rightBtn").addEventListener("pointerdown", () => moveLane(1));

  window.addEventListener("pointerdown", (e) => {
    const x = e.clientX / window.innerWidth;
    if (x < 0.40) moveLane(-1);
    else if (x > 0.60) moveLane(1);
  }, { passive: true });
</script>
</body>
</html>