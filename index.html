<!doctype html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Letter Race 3D</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#0b0f14; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #ui {
      position: fixed; left: 12px; right: 12px; top: 10px;
      display: flex; gap: 10px; align-items: center; justify-content: space-between;
      pointer-events: none;
    }
    .pill {
      pointer-events: auto;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color: #fff;
      padding: 10px 12px;
      border-radius: 14px;
      backdrop-filter: blur(6px);
      -webkit-backdrop-filter: blur(6px);
      display:flex; align-items:center; gap:10px;
      user-select: none;
    }
    #targetLetter { font-size: 18px; font-weight: 800; display:flex; align-items:center; gap:10px; }
    #bigLetter {
      width: 46px; height: 46px; border-radius: 12px;
      background: rgba(255,255,255,0.16);
      display:flex; align-items:center; justify-content:center;
      font-size: 24px; font-weight: 900;
      text-transform: lowercase;
    }
    #status { font-size: 18px; font-weight: 800; }
    #help {
      position: fixed; left: 12px; right: 12px; bottom: 12px;
      display:flex; justify-content: space-between; gap: 10px;
      pointer-events: none;
    }
    .btn {
      pointer-events: auto;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color:#fff;
      padding: 14px 16px;
      border-radius: 16px;
      font-weight: 800;
      min-width: 120px;
      text-align:center;
      user-select:none;
      touch-action: manipulation;
    }
    #overlay {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(ellipse at center, rgba(20,30,45,0.92), rgba(5,7,10,0.96));
      color:#fff;
      z-index: 10;
    }
    #card {
      width: min(760px, calc(100% - 24px));
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      padding: 18px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #card h1 { margin: 0 0 8px 0; font-size: 22px; }
    #card p { margin: 6px 0; opacity: 0.92; line-height: 1.35; }
    #card .row { display:flex; gap: 10px; flex-wrap: wrap; margin-top: 12px; }
    #card .row button {
      background: rgba(255,255,255,0.16);
      border: 1px solid rgba(255,255,255,0.16);
      color:#fff;
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 900;
      cursor: pointer;
    }
    canvas { display:block; }
  </style>
</head>
<body>

<div id="overlay">
  <div id="card">
    <h1>Letter Race 3D</h1>
    <p>Rustige race, pak de juiste kleine letter, de klank is fonemisch via geluid, dus geen letternamen.</p>
    <p>Bediening, tik links of rechts om van baan te wisselen.</p>
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="tempoBtn">Tempo: extra rustig</button>
      <button id="soundBtn">Geluid: aan</button>
    </div>
  </div>
</div>

<div id="ui">
  <div class="pill" id="targetLetter">
    <div id="bigLetter">b</div>
    <div>Doelletter</div>
  </div>
  <div class="pill">
    <div id="status">ðŸ™‚</div>
    <div id="score">Score: 0</div>
  </div>
</div>

<div id="help">
  <div class="btn" id="leftBtn">Links</div>
  <div class="btn" id="rightBtn">Rechts</div>
</div>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  let scene, camera, renderer;

  // Auto
  let car;
  let lane = 1;

  // Rijstroken
  const laneOffsets = [-2.2, 0, 2.2];
  const carZ = 2.2;

  // Tempo
  let baseSpeed = 0.028;
  let speed = baseSpeed;
  let turboTime = 0;
  let slowTime = 0;

  // Letters
  const activeLetters = ["b","g","v","m","z","h","k","l","s","w"];
  let target = "b";
  let score = 0;
  let pickups = [];
  let lastSpawnZ = -18;

  // Weg segmenten, echte bochten
  const road = {
    segments: [],
    laneMarks: [],
    segLen: 7.5,
    segCount: 44,
    halfWidth: 4.8
  };

  // Bochten profiel
  let curvePhase = 0;
  const curvePeriod = 140;
  const curveAmp = 2.1;

  // UI
  const uiBig = document.getElementById("bigLetter");
  const uiStatus = document.getElementById("status");
  const uiScore = document.getElementById("score");
  const overlay = document.getElementById("overlay");
  let running = false;

  // Geluid, fonemisch via Web Audio
  let soundOn = true;
  let audioCtx = null;

  const rng = () => Math.random();

  function ensureAudio() {
    if (!soundOn) return null;
    if (!audioCtx) {
      const AC = window.AudioContext || window.webkitAudioContext;
      audioCtx = new AC();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }

  function makeNoiseBuffer(ctx, seconds = 0.25) {
    const sr = ctx.sampleRate;
    const len = Math.floor(sr * seconds);
    const buffer = ctx.createBuffer(1, len, sr);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < len; i++) data[i] = (Math.random() * 2 - 1);
    return buffer;
  }

  function playFricative(ctx, { voiced = false, duration = 0.26, cutoff = 2200, gain = 0.14, voiceHz = 170 } = {}) {
    const now = ctx.currentTime;

    const noise = ctx.createBufferSource();
    noise.buffer = makeNoiseBuffer(ctx, duration);
    const filt = ctx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.value = cutoff;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(gain, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    noise.connect(filt);
    filt.connect(g);
    g.connect(ctx.destination);

    noise.start(now);
    noise.stop(now + duration);

    if (voiced) {
      const osc = ctx.createOscillator();
      osc.type = "sine";
      osc.frequency.value = voiceHz;

      const vg = ctx.createGain();
      vg.gain.setValueAtTime(0.0001, now);
      vg.gain.exponentialRampToValueAtTime(gain * 0.55, now + 0.02);
      vg.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      osc.connect(vg);
      vg.connect(ctx.destination);
      osc.start(now);
      osc.stop(now + duration);
    }
  }

  function playHum(ctx, { duration = 0.28, hz = 180, gain = 0.16 } = {}) {
    const now = ctx.currentTime;
    const osc = ctx.createOscillator();
    osc.type = "sine";
    osc.frequency.value = hz;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(gain, now + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    osc.connect(g);
    g.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + duration);
  }

  function playPlosive(ctx, { duration = 0.14, freq = 240, gain = 0.18 } = {}) {
    const now = ctx.currentTime;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.value = freq;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(gain, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    const filt = ctx.createBiquadFilter();
    filt.type = "lowpass";
    filt.frequency.value = 900;

    osc.connect(filt);
    filt.connect(g);
    g.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + duration);
  }

  function speakPhoneme(letter) {
    if (!soundOn) return;
    const ctx = ensureAudio();
    if (!ctx) return;

    const l = String(letter).toLowerCase();

    // Dit zijn klanken, niet letternamen
    if (l === "m") return playHum(ctx, { hz: 170, duration: 0.30, gain: 0.15 });
    if (l === "l") return playHum(ctx, { hz: 210, duration: 0.22, gain: 0.12 });
    if (l === "h") return playFricative(ctx, { voiced: false, cutoff: 1400, duration: 0.18, gain: 0.12 });

    if (l === "s") return playFricative(ctx, { voiced: false, cutoff: 3200, duration: 0.24, gain: 0.14 });
    if (l === "z") return playFricative(ctx, { voiced: true, cutoff: 3000, duration: 0.24, gain: 0.13, voiceHz: 170 });
    if (l === "v") return playFricative(ctx, { voiced: true, cutoff: 1700, duration: 0.22, gain: 0.12, voiceHz: 160 });

    if (l === "b") return playPlosive(ctx, { freq: 220, duration: 0.12, gain: 0.18 });
    if (l === "k") return playPlosive(ctx, { freq: 280, duration: 0.11, gain: 0.16 });
    if (l === "g") return playPlosive(ctx, { freq: 200, duration: 0.12, gain: 0.16 });
    if (l === "w") {
      playHum(ctx, { hz: 140, duration: 0.12, gain: 0.10 });
      setTimeout(() => playHum(ctx, { hz: 200, duration: 0.16, gain: 0.11 }), 80);
      return;
    }
  }

  function beep(ok = true) {
    if (!soundOn) return;
    const ctx = ensureAudio();
    if (!ctx) return;
    const now = ctx.currentTime;

    const osc = ctx.createOscillator();
    osc.type = "sine";
    osc.frequency.value = ok ? 520 : 210;

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(0.07, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + (ok ? 0.09 : 0.12));

    osc.connect(g);
    g.connect(ctx.destination);

    osc.start(now);
    osc.stop(now + (ok ? 0.10 : 0.13));
  }

  function setStatus(emoji) { uiStatus.textContent = emoji; }
  function updateScore() { uiScore.textContent = `Score: ${score}`; }

  function setTarget(newTarget) {
    target = String(newTarget).toLowerCase();
    uiBig.textContent = target;
    speakPhoneme(target);
  }

  function pickNewTarget() {
    setTarget(activeLetters[Math.floor(rng() * activeLetters.length)]);
  }

  // Bocht functies
  function trackOffsetX(z) {
    return curveAmp * Math.sin(((z + curvePhase) / curvePeriod) * Math.PI * 2);
  }

  function trackDeriv(z) {
    // dx/dz afgeleid van sinus
    const w = (Math.PI * 2) / curvePeriod;
    return curveAmp * Math.cos(((z + curvePhase) / curvePeriod) * Math.PI * 2) * w;
  }

  function laneXAtZ(laneIndex, z) {
    return trackOffsetX(z) + laneOffsets[laneIndex];
  }

  function yawAtZ(z) {
    const d = trackDeriv(z);
    return Math.atan(d);
  }

  // Letters
  function makeTextSprite(letter) {
    const canvas = document.createElement("canvas");
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext("2d");

    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0,0,256,256);

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fillRect(20,20,216,216);

    ctx.font = "900 140px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "white";
    ctx.fillText(String(letter).toLowerCase(), 128, 138);

    const tex = new THREE.CanvasTexture(canvas);
    tex.anisotropy = 8;
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sprite = new THREE.Sprite(mat);
    sprite.scale.set(1.25, 1.25, 1);
    return sprite;
  }

  function createPickup(letter, laneIndex, z) {
    const group = new THREE.Group();

    const baseGeom = new THREE.BoxGeometry(1.05, 0.7, 1.05);
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x9aa6b2, roughness: 0.45, metalness: 0.18 });
    const base = new THREE.Mesh(baseGeom, baseMat);
    base.position.y = 0.38;
    group.add(base);

    const sprite = makeTextSprite(letter);
    sprite.position.set(0, 1.05, 0.55);
    group.add(sprite);

    group.position.set(laneXAtZ(laneIndex, z), 0, z);
    group.userData = { letter: String(letter).toLowerCase(), laneIndex, hit: false };

    scene.add(group);
    pickups.push(group);
  }

  function spawnSet() {
    const z = lastSpawnZ - 40 - rng() * 22;
    lastSpawnZ = z;

    const correctLane = Math.floor(rng() * 3);

    // Altijd precies Ã©Ã©n correcte letter
    createPickup(target, correctLane, z);

    const others = activeLetters.filter(l => l !== target);
    for (let i = 0; i < 3; i++) {
      if (i === correctLane) continue;
      const l = others[Math.floor(rng() * others.length)];
      createPickup(l, i, z);
    }
  }

  // Auto textures
  function setCarTexture(key) {
    if (!car || !car.userData || !car.userData.plane) return;
    const t = car.userData.tex[key];
    if (!t) return;
    car.userData.plane.material.map = t;
    car.userData.plane.material.needsUpdate = true;
  }

  // Weg bouwen met segmenten die kunnen draaien
  function makeRoadSegment() {
    const geom = new THREE.PlaneGeometry(road.halfWidth * 2, road.segLen, 1, 1);
    const mat = new THREE.MeshStandardMaterial({ color: 0x111a24, roughness: 0.95, metalness: 0.0 });
    const m = new THREE.Mesh(geom, mat);
    m.rotation.x = -Math.PI / 2;
    return m;
  }

  function makeLaneMark() {
    const geom = new THREE.BoxGeometry(0.12, 0.02, road.segLen * 0.62);
    const mat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.85, metalness: 0.0 });
    const m = new THREE.Mesh(geom, mat);
    return m;
  }

  function setupThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f14, 12, 170);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    document.body.appendChild(renderer.domElement);

    // Orthographic camera, dus rustig en leesbaar
    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 10.8;
    camera = new THREE.OrthographicCamera(
      -viewSize * aspect, viewSize * aspect,
      viewSize, -viewSize,
      0.1, 600
    );
    camera.position.set(0, 16, 12);
    camera.lookAt(0, 0.8, -18);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x1b2430, 1.0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 1.05);
    dir.position.set(6, 12, 6);
    scene.add(dir);

    // Weg segmenten, elk segment draait mee met de bocht
    for (let i = 0; i < road.segCount; i++) {
      const seg = makeRoadSegment();
      const z = -i * road.segLen;
      seg.position.set(trackOffsetX(z), 0, z);
      seg.rotation.y = yawAtZ(z);
      seg.userData = { z };
      scene.add(seg);
      road.segments.push(seg);

      // Lane marks op twee posities, links en rechts van midden
      const leftMark = makeLaneMark();
      leftMark.position.set(trackOffsetX(z) - 1.1, 0.02, z);
      leftMark.rotation.y = yawAtZ(z);
      leftMark.userData = { z, baseX: -1.1 };
      scene.add(leftMark);
      road.laneMarks.push(leftMark);

      const rightMark = makeLaneMark();
      rightMark.position.set(trackOffsetX(z) + 1.1, 0.02, z);
      rightMark.rotation.y = yawAtZ(z);
      rightMark.userData = { z, baseX: 1.1 };
      scene.add(rightMark);
      road.laneMarks.push(rightMark);
    }

    // Auto als plaatje
    const texLoader = new THREE.TextureLoader();
    const carTex = {
      straight: texLoader.load("./car_straight.png"),
      left: texLoader.load("./car_left.png"),
      right: texLoader.load("./car_right.png"),
    };
    for (const k of Object.keys(carTex)) {
      carTex[k].colorSpace = THREE.SRGBColorSpace;
      carTex[k].anisotropy = 8;
    }

    const carGroup = new THREE.Group();
    const carPlaneGeom = new THREE.PlaneGeometry(2.9, 2.9);
    const carPlaneMat = new THREE.MeshBasicMaterial({ map: carTex.straight, transparent: true });
    const carPlane = new THREE.Mesh(carPlaneGeom, carPlaneMat);
    carPlane.position.set(0, 1.15, 0);
    carPlane.rotation.x = -0.22;
    carGroup.add(carPlane);

    const shadow = new THREE.Mesh(
      new THREE.CircleGeometry(1.05, 26),
      new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25 })
    );
    shadow.rotation.x = -Math.PI / 2;
    shadow.position.y = 0.02;
    carGroup.add(shadow);

    car = carGroup;
    car.position.set(laneXAtZ(lane, carZ), 0, carZ);
    scene.add(car);

    car.userData = {
      plane: carPlane,
      tex: carTex,
      blinkFrames: 0,
      wobbleFrames: 0,
      wobbleDir: 0
    };

    setTarget(activeLetters[0]);
    for (let i = 0; i < 3; i++) spawnSet();

    window.addEventListener("resize", onResize);
  }

  function onResize() {
    if (!renderer || !camera) return;
    renderer.setSize(window.innerWidth, window.innerHeight);

    const aspect = window.innerWidth / window.innerHeight;
    const viewSize = 10.8;
    camera.left = -viewSize * aspect;
    camera.right = viewSize * aspect;
    camera.top = viewSize;
    camera.bottom = -viewSize;
    camera.updateProjectionMatrix();
  }

  function moveLane(dir) {
    const prev = lane;
    lane = Math.max(0, Math.min(2, lane + dir));
    if (lane === prev) return;

    // Auto blijft langer gedraaid, zodat kleuters het snappen
    const key = dir < 0 ? "left" : "right";
    setCarTexture(key);
    car.userData.blinkFrames = 24;

    // Langer wiebelen, zacht
    car.userData.wobbleFrames = 30;
    car.userData.wobbleDir = dir < 0 ? -1 : 1;
  }

  function checkCollisions() {
    for (const p of pickups) {
      if (p.userData.hit) continue;

      const dz = Math.abs(p.position.z - carZ);
      const dx = Math.abs(p.position.x - car.position.x);

      if (dz < 1.15 && dx < 1.05) {
        p.userData.hit = true;

        const ok = p.userData.letter === target;
        if (ok) {
          score += 1;
          turboTime = 75;
          slowTime = 0;
          setStatus("ðŸ˜„");
          beep(true);
          pickNewTarget();
        } else {
          slowTime = 95;
          turboTime = 0;
          setStatus("ðŸ˜¬");
          beep(false);
          speakPhoneme(target);
        }

        updateScore();
        scene.remove(p);
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);
  }

  function tick() {
    if (!running) return;

    // Bochten schuiven rustig door
    curvePhase += speed * 10;

    // Auto naar rijstrook, inclusief bocht
    const desiredX = laneXAtZ(lane, carZ);
    car.position.x += (desiredX - car.position.x) * 0.11;

    // Auto flits, langer zichtbaar
    if (car.userData.blinkFrames > 0) {
      car.userData.blinkFrames -= 1;
      if (car.userData.blinkFrames === 0) setCarTexture("straight");
    }

    // Wiebelen
    if (car.userData.wobbleFrames > 0) {
      car.userData.wobbleFrames -= 1;
      const t = car.userData.wobbleFrames / 30;
      const wobble = Math.sin((1 - t) * Math.PI) * 0.16 * car.userData.wobbleDir;
      car.rotation.z = wobble;
      car.rotation.y = wobble * 0.25;
    } else {
      car.rotation.z += (0 - car.rotation.z) * 0.18;
      car.rotation.y += (0 - car.rotation.y) * 0.18;
    }

    // Snelheid
    let targetSpeed = baseSpeed;
    if (turboTime > 0) {
      turboTime -= 1;
      targetSpeed = baseSpeed * 1.12;
    } else if (slowTime > 0) {
      slowTime -= 1;
      targetSpeed = baseSpeed * 0.58;
    } else {
      setStatus("ðŸ™‚");
    }
    speed += (targetSpeed - speed) * 0.06;

    // Weg segmenten bewegen naar voren en worden opnieuw geplaatst achteraan
    const forward = speed * 10;
    const resetZ = -road.segCount * road.segLen;

    for (const seg of road.segments) {
      seg.position.z += forward;

      if (seg.position.z > road.segLen) {
        seg.position.z += resetZ;
      }

      const z = seg.position.z;
      seg.position.x = trackOffsetX(z);
      seg.rotation.y = yawAtZ(z);
    }

    for (const m of road.laneMarks) {
      m.position.z += forward;

      if (m.position.z > road.segLen) {
        m.position.z += resetZ;
      }

      const z = m.position.z;
      m.position.x = trackOffsetX(z) + m.userData.baseX;
      m.rotation.y = yawAtZ(z);
    }

    // Pickups bewegen en volgen de bocht
    for (const p of pickups) {
      p.position.z += forward;

      const z = p.position.z;
      p.position.x = laneXAtZ(p.userData.laneIndex, z);

      if (p.position.z > 10) {
        scene.remove(p);
        p.userData.hit = true;
      }
    }
    pickups = pickups.filter(p => !p.userData.hit);

    // Genoeg lettersets, telkens 3 met 1 juiste
    while (pickups.length < 9) spawnSet();

    checkCollisions();

    // Camera volgt zacht
    camera.position.x += (car.position.x - camera.position.x) * 0.06;
    camera.lookAt(camera.position.x, 0.8, -18);

    renderer.render(scene, camera);
    requestAnimationFrame(tick);
  }

  function bindControls() {
    const leftBtn = document.getElementById("leftBtn");
    const rightBtn = document.getElementById("rightBtn");

    const left = () => moveLane(-1);
    const right = () => moveLane(1);

    leftBtn.addEventListener("pointerdown", () => { ensureAudio(); left(); });
    rightBtn.addEventListener("pointerdown", () => { ensureAudio(); right(); });

    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowLeft") { ensureAudio(); left(); }
      if (e.key === "ArrowRight") { ensureAudio(); right(); }
    });

    window.addEventListener("pointerdown", (e) => {
      ensureAudio();
      const x = e.clientX / window.innerWidth;
      if (x < 0.40) left();
      else if (x > 0.60) right();
    }, { passive: true });
  }

  function startGame() {
    if (!scene) setupThree();
    ensureAudio();
    running = true;
    overlay.style.display = "none";
    tick();
  }

  document.getElementById("startBtn").addEventListener("click", startGame);

  document.getElementById("tempoBtn").addEventListener("click", (e) => {
    if (baseSpeed > 0.024) {
      baseSpeed = 0.019;
      e.target.textContent = "Tempo: super rustig";
    } else {
      baseSpeed = 0.028;
      e.target.textContent = "Tempo: extra rustig";
    }
  });

  document.getElementById("soundBtn").addEventListener("click", (e) => {
    soundOn = !soundOn;
    e.target.textContent = soundOn ? "Geluid: aan" : "Geluid: uit";
    if (!soundOn && audioCtx) {
      try { audioCtx.suspend(); } catch {}
    } else {
      ensureAudio();
      speakPhoneme(target);
    }
  });

  bindControls();
</script>
</body>
</html>