<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Letter Race</title>

<style>
  html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#111; font-family: Arial, sans-serif; }
  canvas { display:block; }

  #ui{
    position:absolute; top:12px; left:12px;
    color:#fff; font-size:16px;
    background:rgba(0,0,0,.35);
    padding:10px 12px; border-radius:12px;
    backdrop-filter: blur(4px);
    max-width: min(560px, calc(100vw - 24px));
  }
  #ui .row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }

  .pill{
    display:inline-flex; align-items:center; gap:8px;
    padding:6px 10px; border-radius:999px;
    background:rgba(0,0,0,.28);
    white-space:nowrap;
  }
  .targetBox{
    width:34px; height:34px; border-radius:10px;
    display:inline-flex; align-items:center; justify-content:center;
    background:rgba(255,255,255,.18);
    border:2px solid rgba(255,255,255,.35);
    font-weight:700;
  }

  .controls{
    margin-top:10px;
    padding-top:10px;
    border-top: 1px solid rgba(255,255,255,.18);
    display:grid;
    gap:8px;
  }
  .ctrl{
    display:grid;
    grid-template-columns: 140px 1fr 70px;
    gap:10px;
    align-items:center;
  }
  .ctrl input[type="range"]{ width:100%; }
  .value{
    text-align:right;
    font-variant-numeric: tabular-nums;
    opacity:0.95;
  }

  /* debug overlay */
  #err{
    position:absolute;
    left:12px;
    right:12px;
    bottom:12px;
    padding:10px 12px;
    border-radius:12px;
    background:rgba(140,0,0,.60);
    color:#fff;
    font-size:14px;
    line-height:1.25;
    display:none;
    white-space:pre-wrap;
  }
</style>
</head>

<body>

<div id="ui">
  <div class="row">
    <span class="pill">Energie: <span id="energy">100</span></span>
    <span class="pill">Letter: <span class="targetBox" id="targetLetter">a</span></span>
    <span class="pill">Tempo: <span id="tempo">1.00</span></span>
  </div>

  <div class="controls">
    <div class="ctrl">
      <label for="treeStart">Bomen start</label>
      <input id="treeStart" type="range" min="0.05" max="3.00" step="0.01" value="0.22">
      <div class="value"><span id="treeStartVal">0.22</span></div>
    </div>

    <div class="ctrl">
      <label for="treeEnd">Bomen eind</label>
      <input id="treeEnd" type="range" min="2.0" max="60.0" step="0.1" value="18.0">
      <div class="value"><span id="treeEndVal">18.0</span></div>
    </div>
  </div>
</div>

<div id="err"></div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const errBox = document.getElementById("err");
function showErr(msg){
  errBox.style.display = "block";
  errBox.textContent = msg;
}

window.onerror = (message, source, lineno, colno) => {
  showErr(
    "Fout bij laden\n" +
    String(message) + "\n" +
    "Regel: " + lineno + " Kolom: " + colno + "\n" +
    "Bron: " + (source || "")
  );
};

function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize);
resize();

const uiEnergy = document.getElementById("energy");
const uiTarget = document.getElementById("targetLetter");
const uiTempo  = document.getElementById("tempo");

const treeStartSlider = document.getElementById("treeStart");
const treeEndSlider   = document.getElementById("treeEnd");
const treeStartVal    = document.getElementById("treeStartVal");
const treeEndVal      = document.getElementById("treeEndVal");

function loadImg(src){
  const img = new Image();
  img.src = src;
  img.onerror = () => {
    showErr("Afbeelding kan niet laden\n" + src + "\nControleer bestandsnaam, hoofdletters, map, en GitHub Pages pad");
  };
  return img;
}

const carStraight = loadImg("car_straight.png");
const carLeft = loadImg("car_left.png");
const carRight = loadImg("car_right.png");
const treeImg = loadImg("tree.png");

function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function mod(n,m){ return ((n % m) + m) % m; }
function lerp(a,b,t){ return a + (b-a)*t; }

let energy = 100;
let roadScroll = 0;
let tempoFactor = 1.0;

const letters = "aeioumkstprln".split("");
let targetLetter = letters[Math.floor(Math.random()*letters.length)];
uiTarget.textContent = targetLetter;

let targetTimer = 0;
const TARGET_SWITCH_SECONDS = 9;

const state = { lane: 1, lastTime: performance.now() };

const car = {
  x: canvas.width/2,
  y: canvas.height * 0.78,
  tilt: 0,
  steerDx: 0,
  w: 150,
  h: 90
};

const items = [];
const MAX_ITEMS = 2;
const SPAWN_FRAMES_BASE = 170;

const SPEED_UP = 0.12;
const SPEED_DOWN = 0.10;
const SPEED_MIN = 0.70;
const SPEED_MAX = 2.20;
const RELAX_TO_ONE = 0.004;

/* boom parameters via sliders */
let treeAccelStart = parseFloat(treeStartSlider.value);
let treeAccelEnd   = parseFloat(treeEndSlider.value);

function syncTreeUI(){
  treeAccelStart = parseFloat(treeStartSlider.value);
  treeAccelEnd   = parseFloat(treeEndSlider.value);
  treeStartVal.textContent = treeAccelStart.toFixed(2);
  treeEndVal.textContent   = treeAccelEnd.toFixed(1);
}
treeStartSlider.addEventListener("input", syncTreeUI);
treeEndSlider.addEventListener("input", syncTreeUI);
syncTreeUI();

/* weg geometrie */
function roadWidthAt(y){
  const t = clamp(y / canvas.height, 0, 1);
  return canvas.width * 0.30 + (canvas.width * 0.90 - canvas.width * 0.30) * (t ** 1.6);
}

function roadCenterXAt(y){
  const t = clamp(y / canvas.height, 0, 1);
  const slow = Math.sin(roadScroll / 720) * (canvas.width * 0.03);
  return canvas.width / 2 + slow * (1 - t);
}

function roadEdgesAt(y){
  const w = roadWidthAt(y);
  const cx = roadCenterXAt(y);
  return { left: cx - w/2, right: cx + w/2, cx, w };
}

function laneX(lane, y){
  const e = roadEdgesAt(y);
  const laneW = e.w / 3;
  return e.left + laneW * (lane + 0.5);
}

/* bomen */
const trees = [];
const MAX_TREES = 4;
const TREE_SPAWN_FRAMES_BASE = 240;
let treeSpawnTimer = 0;

function spawnTree(){
  if(trees.length >= MAX_TREES) return;

  const side = Math.random() < 0.5 ? "left" : "right";
  const sizeSeed = 0.88 + Math.random() * 0.28;

  trees.push({
    side,
    baseY: -460,
    sizeSeed
  });
}

function treeX(tr){
  const e = roadEdgesAt(tr.baseY);
  const t = clamp(tr.baseY / canvas.height, 0, 1);

  const margin = 46 + t * 190; // dicht bij weg, groeit naar beneden mee
  return tr.side === "left" ? (e.left - margin) : (e.right + margin);
}

function treeSize(tr){
  const t = clamp(tr.baseY / canvas.height, 0, 1);
  const p = t ** 1.05;

  const w = (18 + p * 1180) * tr.sizeSeed;
  const h = w * 1.10;

  return { w, h };
}

function updateTrees(dt){
  treeSpawnTimer += dt;
  const threshold = (TREE_SPAWN_FRAMES_BASE / tempoFactor);
  if(treeSpawnTimer > threshold){
    treeSpawnTimer = 0;
    spawnTree();
  }

  for(let i = trees.length - 1; i >= 0; i--){
    const tr = trees[i];
    const t = clamp(tr.baseY / canvas.height, 0, 1);

    const curve = 2.25; // snelle opbouw naar eind
    const accel = lerp(treeAccelStart, treeAccelEnd, t ** curve);

    let dy = (accel * tempoFactor) * dt * 3.0;

    // frame spike guard, maar niet verstikkend
    const maxStep = 160 * dt * tempoFactor;
    dy = Math.min(dy, maxStep);

    tr.baseY += dy;

    const h = treeSize(tr).h;
    if(tr.baseY - h > canvas.height + 80) trees.splice(i, 1);
  }
}

function drawTrees(){
  for(const tr of trees){
    const { w, h } = treeSize(tr);
    const x = treeX(tr);
    const topY = tr.baseY - h;
    const shadowY = tr.baseY + h * 0.06;

    ctx.fillStyle = "rgba(0,0,0,0.22)";
    ctx.beginPath();
    ctx.ellipse(x, shadowY, w * 0.34, h * 0.12, 0, 0, Math.PI * 2);
    ctx.fill();

    if(treeImg.complete && treeImg.naturalWidth){
      ctx.drawImage(treeImg, x - w/2, topY, w, h);
    } else {
      // placeholder boom
      ctx.fillStyle = "rgba(10,70,30,0.8)";
      ctx.beginPath();
      ctx.ellipse(x, tr.baseY - h*0.55, w*0.35, h*0.25, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = "rgba(90,55,25,0.9)";
      ctx.fillRect(x - w*0.07, tr.baseY - h*0.35, w*0.14, h*0.35);
    }
  }
}

/* letters */
function drawItem(it){
  const t = clamp(it.y / canvas.height, 0, 1);
  const size = 26 + t * 125;
  const fontSize = Math.floor(14 + t * 58);

  ctx.fillStyle = it.isTarget ? "rgba(170,225,255,0.95)" : "rgba(255,220,120,0.95)";
  ctx.fillRect(it.x - size/2, it.y - size/2, size, size);

  ctx.fillStyle = "#111";
  ctx.font = `700 ${fontSize}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(it.letter, it.x, it.y);
}

function spawnLetter(){
  if(items.length >= MAX_ITEMS) return;

  const lane = Math.floor(Math.random() * 3);
  const isTarget = Math.random() < 0.33;
  const letter = isTarget ? targetLetter : letters[Math.floor(Math.random() * letters.length)];

  items.push({ lane, y: -70, letter, isTarget, vy: 8.2 });
}

let spawnTimer = 0;

function updateTargetLetter(dt){
  targetTimer += dt / 60;
  if(targetTimer >= TARGET_SWITCH_SECONDS){
    targetTimer = 0;
    let next = targetLetter;
    while(next === targetLetter) next = letters[Math.floor(Math.random() * letters.length)];
    targetLetter = next;
    uiTarget.textContent = targetLetter;
  }
}

function updateTempoRelax(dt){
  const diff = 1.0 - tempoFactor;
  tempoFactor += diff * (RELAX_TO_ONE * dt);
  tempoFactor = clamp(tempoFactor, SPEED_MIN, SPEED_MAX);
}

/* teken */
function drawGrass(){
  ctx.fillStyle = "#3aa64b";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  for(let i=0; i<12; i++){
    const x = (i * canvas.width / 12) + (Math.sin(roadScroll/210 + i) * 18);
    const y = (i * 140 + roadScroll * 1.25) % (canvas.height + 220) - 110;
    ctx.fillStyle = "rgba(0,0,0,0.05)";
    ctx.beginPath();
    ctx.ellipse(x, y, 120, 60, 0, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawRoad(){
  const pts = [];
  for(let y=0; y<=canvas.height+28; y+=28){
    const e = roadEdgesAt(y);
    pts.push({ y, left: e.left, right: e.right, cx: e.cx, w: e.w });
  }

  // asfalt
  ctx.beginPath();
  ctx.moveTo(pts[0].left, pts[0].y);
  for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].left, pts[i].y);
  for(let i=pts.length-1; i>=0; i--) ctx.lineTo(pts[i].right, pts[i].y);
  ctx.closePath();
  ctx.fillStyle = "#505050";
  ctx.fill();

  // band buiten de weg
  for(let i=0; i<pts.length-1; i++){
    const p1 = pts[i];
    const p2 = pts[i+1];
    const t = clamp(p1.y / canvas.height, 0, 1);

    const bandW = 3 + t * 22;
    const offset = bandW * 0.75;

    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = bandW;
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(p1.left - offset, p1.y);
    ctx.lineTo(p2.left - offset, p2.y);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(p1.right + offset, p1.y);
    ctx.lineTo(p2.right + offset, p2.y);
    ctx.stroke();
  }

  // randlijnen
  ctx.strokeStyle = "rgba(255,255,255,0.60)";
  ctx.lineWidth = 4;
  ctx.lineCap = "round";

  ctx.beginPath();
  ctx.moveTo(pts[0].left + 3, pts[0].y);
  for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].left + 3, pts[i].y);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(pts[0].right - 3, pts[0].y);
  for(let i=1; i<pts.length; i++) ctx.lineTo(pts[i].right - 3, pts[i].y);
  ctx.stroke();

  // middenstrepen, stabiel zonder tempo wobble en zonder overlap
  const H = canvas.height;
  const projScale = 0.0042;

  function yFromS(s){
    return H / (1 + s * projScale);
  }

  const periodS = 260;
  const dashS   = 105;
  const sOffset = (periodS - (roadScroll % periodS)) % periodS;

  let guard = 0;
  const GUARD_MAX = 220;

  for(let s = sOffset; ; s += periodS){
    guard++;
    if(guard > GUARD_MAX) break;

    const y1 = yFromS(s);
    if(y1 <= 0.5) break;

    const y2 = yFromS(s + dashS);
    const cx = roadCenterXAt(y1);
    const t = clamp(y1 / H, 0, 1);

    ctx.strokeStyle = "rgba(255,245,190,0.80)";
    ctx.lineWidth = lerp(8, 22, t);
    ctx.lineCap = "round";

    ctx.beginPath();
    ctx.moveTo(cx, y1);
    ctx.lineTo(cx, y2);
    ctx.stroke();
  }
}

function chooseCarSprite(){
  if(car.steerDx < -18) return carLeft;
  if(car.steerDx > 18) return carRight;
  return carStraight;
}

function drawCar(){
  const base = Math.min(canvas.width, canvas.height);
  const w = Math.max(176, base * 0.275);
  const h = w * 0.62;
  car.w = w;
  car.h = h;

  const img = chooseCarSprite();

  ctx.save();
  ctx.translate(car.x, car.y);
  ctx.rotate(car.tilt * 0.40);

  ctx.fillStyle = "rgba(0,0,0,0.22)";
  ctx.beginPath();
  ctx.ellipse(0, h * 0.36, w * 0.34, h * 0.22, 0, 0, Math.PI * 2);
  ctx.fill();

  if(img.complete && img.naturalWidth){
    ctx.drawImage(img, -w/2, -h/2, w, h);
  } else {
    // placeholder auto
    ctx.fillStyle = "rgba(220,40,40,0.95)";
    ctx.fillRect(-w*0.35, -h*0.20, w*0.70, h*0.40);
  }
  ctx.restore();
}

/* update */
function update(dt){
  energy = Math.max(0, energy - 0.018 * dt);
  uiEnergy.textContent = Math.floor(energy);

  updateTargetLetter(dt);
  updateTempoRelax(dt);

  roadScroll += (9.2 * tempoFactor) * dt;
  uiTempo.textContent = tempoFactor.toFixed(2);

  // auto naar lane
  const targetX = laneX(state.lane, car.y);
  const dx = targetX - car.x;
  car.steerDx = dx;
  car.x += dx * (0.085 * dt);
  car.tilt += (clamp(dx / (canvas.width * 0.75), -0.28, 0.28) - car.tilt) * (0.09 * dt);

  // letters spawn
  spawnTimer += dt;
  const spawnThreshold = SPAWN_FRAMES_BASE / tempoFactor;
  if(spawnTimer > spawnThreshold){
    spawnTimer = 0;
    spawnLetter();
  }

  // letters bewegen
  for(let i = items.length - 1; i >= 0; i--){
    const it = items[i];
    it.y += (it.vy * tempoFactor) * dt;
    it.x = laneX(it.lane, it.y);

    const hit = Math.abs(it.x - car.x) < car.w * 0.36 && Math.abs(it.y - car.y) < car.h * 0.36;

    if(hit){
      if(it.isTarget){
        tempoFactor = clamp(tempoFactor + SPEED_UP, SPEED_MIN, SPEED_MAX);
        targetTimer = TARGET_SWITCH_SECONDS;
      } else {
        tempoFactor = clamp(tempoFactor - SPEED_DOWN, SPEED_MIN, SPEED_MAX);
      }

      energy = Math.min(140, energy + 10);
      items.splice(i, 1);
      continue;
    }

    if(it.y > canvas.height + 160) items.splice(i, 1);
  }

  updateTrees(dt);
}

function draw(){
  drawGrass();
  drawRoad();

  // letters onder de auto
  for(const it of items) drawItem(it);

  // auto
  drawCar();

  // bomen voor de auto
  drawTrees();
}

/* loop */
function loop(now){
  try{
    const dt = Math.min(3, (now - state.lastTime) / (1000/60));
    state.lastTime = now;

    if(energy > 0) update(dt);
    draw();

    requestAnimationFrame(loop);
  } catch(e){
    showErr("Runtime fout\n" + (e && e.stack ? e.stack : String(e)));
  }
}
requestAnimationFrame(loop);

/* besturing */
canvas.addEventListener("pointerdown", (e)=>{
  const x = e.clientX;
  if(x < canvas.width / 3) state.lane = 0;
  else if(x < canvas.width * 2 / 3) state.lane = 1;
  else state.lane = 2;
});
</script>

</body>
</html>